# 通俗解释CRC

## 起因
今天看以太网相关的资料，看到了这样一句话

>对于以太网，第二层的最后面是`CRC`，也就是循环冗余检测。通过 `XOR` 异或的算法，来 计算整个包是否在发送的过程中出现了错误，主要解决第三个问题。

对`CRC`一脸茫然，然后整理了下相关资料

## 介绍
循环冗余校验（Cyclic redundancy check）通称`CRC`，是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。

`CRC`检验原理实际上就是在一个`k`位二进制数据序列之后附加一个`r`位二进制检验码(序列)，从而构成一个总长为`n＝k＋r`位的二进制序列；附加在数据序列之后的这个检验码与数据序列的内容之间存在着某种特定的关系。如果因干扰等原因使数据序列中的某一位或某些位发生错误，这种特定关系就会被破坏。因此，通过检查这一关系，就可以实现对数据正确性的检验。

结构如下图所示

![CRC](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D250/sign=69198db8bda1cd1101b675258913c8b0/a50f4bfbfbedab64928a2448f036afc378311eb9.jpg)

## 实现原理

`CRC`同其他差错检测方式一样，通过在要传输的k比特数据D后添加(n-k)比特冗余位F（FCS），F形成n比特的传输帧T，再将其发送。

不同的是，`CRC`提供一个预先设定的`n-k+1`比特的整数`P`，并要求添加的长度为`n-k`比特的`F`满足以下公式

```
T mod P == 0......(1)

T = 2^n-k*D+F
```

基于上述要求，实际应用时，发送方和接收方按以下方式通信：

1. 发送方和接收方在通信前，约定好预设整数P。
2. 发送方在发送前根据数据D确定满足(1)式的F，生成CRC码 T，T 即为数据位D与校验位F的拼接，发送T。
3. 接收方收到CRC码 T，进行 result = T mod P 运算，当且仅当result = 0时接收方认为没有差错。

## 一些集成概念

### FCS
Frame Check Sequence（帧校验序列）百度百科里面写的挺复杂的，其实就是一个为了进行差错校验而追加的冗余码

### 生成多项式

>生成多项式（generator polynomial）就是用来把要进行防错处理的二进制码流进行转换生成校验码，然后接收方会收到原始的二进制码流和校验码，按照与发送方相同的多项式再次进行转换生成校验码，与发来的校验码进行比较。如果一致则说明接收到的二进制码流是正确的；反之则说明接收到的二进制码流包含错误。

在`CRC`这块来说，就是发送方和接收方共同的约定一个模2运算的除数。

#### 常见的生成多项式
|名称|生成多项式|
|:--|:--|
|CRC-1|×+1|
|CRC-3-GSM|x³+x+1|
|CRC-4-ITU|x∧4+x+1|
|CRC-5-EPC|x∧5+x³+1|
|CRC-6-GSM|x∧6+x∧5+x³+x²+x+1|
|CRC-7|x∧7+x³+1|
|CRC-8|x∧8+x∧7+x∧6+x∧4+x²+x+1|
|CRC-11|x∧11+x∧9+x∧8+x∧7+x∧4+x²+1|
|CRC-12|x∧12+x∧11+x³+x²+x+1|

>CRC-1其实就是大名鼎鼎的奇偶校验，是一种特殊的循环冗余校验

### 模2运算

> 模2运算是一种二进制算法，CRC校验技术中的核心部分。与四则运算相同，模2运算也包括模2加、模2减、模2乘、模2除四种二进制运算。而且，模2运算也使用与四则运算相同的运算符，即“+”表示模2加，“－”表示模2减，“×”或“·”表示模2乘，“÷”或“/”表示模2除。与四则运算不同的是模2运算不考虑进位和借位，即模2加法是不带进位的二进制加法运算，模2减法是不带借位的二进制减法运算。这样，两个二进制位相运算时，这两个位的值就能确定运算结果，不受前一次运算的影响，也不对下一次造成影响。

在`CRC`中主要就是模2除运算，简单介绍下吧

主要就是做`XRO`(异或)，只是除的时候，并不是真的除，而是用异或来做的，相同为0，不同为1 方法如下所示

![模2除法](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=e86d3c898b18367ab984778f4f1ae0b1/f3d3572c11dfa9ecd22fa7b76fd0f703918fc109.jpg)


## 实践

假设我们要发送的信息码（数据）`D` = `111101` 我们采用`CRC-3-GSM`生成多项式`G` = `x³+x+1`进行计算，这个时候我们需要计算出生成多项式对应的二进制位表示。

### 计算生成多项式二进制表示求法

>对于任意k位二进制数D =dk-1…d2d1d0，其对应的多项式为

>D(X) = ∑di*Xi，i∊[0, k) …… (7)

实际上我们计算的时候，可以使用一点捷径，最简单就是查看以高幂作为长度然后判断每个位置上有没有对应的幂，举个例子.
比如 ，这个表达式的最高次幂是6，我们把这个表达式转化一成这样的`x^6 + x^5 + x^4 + x^3 + x^2 +x^1 + x^0`，然后带入表达式中。

```
x^6 有吗   有 1
x^5 有吗   有 1
x^4 有吗 没有 0
x^3 有吗   有 1
x^2 有吗   有 1
x^1 有吗   有 1
x^0 有吗   有 1
```

组合在一起，然后我们的生成多项式是`x∧6+x∧5+x³+x²+x+1`的二进制表示就是`1101111`

所以不难求出生成多项式`G`的二进制表示就是 `1011`，占`4`位，计做`R`=`4`

### 计算帧检验序列
这个地方的余数，值得是进行模2除法运算之后的余数，我们暂时管它叫`F`

首先我们需要左移信息码，左移位数是生成多项式最高幂，给`D`左移3位，得到`111101000`

然后我们用左移之后的信息位对生成多项式G做模2除法运算，就可得到帧检验序列（冗余码）`F`，作为余数，`F`的位数必须是`R - 1`，如果位数不足，那么在高位补`0`。

商不用关，余数是`10`，由于这里R是`4`，所以需要在高位补`0`，凑齐`3`位，结果就是`010`

结题过程如下：

![求解过程](https://dev.tencent.com/u/lightWay/p/notebook/git/raw/master/imageHost/2019/08/1.jpg)

### 生成CRC码
我们把信息码和帧检验序列连接起来就是我们所说的`CRC`码.

```
T= D + F
```

这个地方我们的`CRC`码就是`111101010`

### 校验
当接收方收到数据后，用收到的数据`T`对G（事先约定好的生成多项式）进行模2除法，若余数为0，则认为数据传输无差错；若余数不为0，则认为数据传输出现了错误，由于不知道错误发生在什么地方，因而不能进行自动纠正，一般的做法是丢弃接收的数据。

![校验结果](https://dev.tencent.com/u/lightWay/p/notebook/git/raw/master/imageHost/2019/08/2.jpg)

我们这里使用`111101010`对`111101`做模2除法，可以看到余数为0。代表我们这条数据传输没问题。

## 总结
一整套下来，不难发现，其实这个原理是很简单的，就是在原有数据基础上加了校验位，然后数据接收方，通过校验位来检测数据的完整性。

在日常生活中我们也经常用到，比如有时候客户端传参的时候，会对特定参数做MD5比对啊，甚至`CSRF`都可以看做是一类方式，只是CRC是公开的，主要用来检测数据完整性，我们平时的传参的一些骚操作是为了检测数据的正确性，都是一个道理。